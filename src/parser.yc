%{
#include <string>
#include <vector>
#include <memory>
%}

%code requires {
#include "node.hh"
}

%code {
#include "driver.hh"
}

%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations
%define api.namespace {goat}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose
%verbose

%param {void *scanner}
%param {goat::location &loc}
%parse-param {std::shared_ptr<goat::node::Program> &result}

%token END 0 "end of file"
%token PROGRAM "program"
%token IF "if"
%token THEN "then"
%token ELSE "else"
%token DO "do"
%token DONE "done"
%token START_AT "start at"
%token REPEAT "repeat"
%token TIMES "times"
%token RETURNS "->"
%token RETURN "return"
%token EQUALS "="
%token COLON ":"
%token PLUS "+"
%token MINUS "-"
%token STAR "*"
%token SLASH "/"
%token LPAREN "("
%token CALL "function call"
%token RPAREN ")"
%token COMMA ","

%token <double> NUMBER "number"
%token <std::string> IDENT "identifier"
%token <std::string> STRING "string"

%printer { yyoutput << $$; } <*>;

%type <std::shared_ptr<node::Program>> program expressions;
%type <std::shared_ptr<node::Node>> expression;
%type <std::shared_ptr<node::String>> string;
%type <std::shared_ptr<node::Number>> number;
%type <std::shared_ptr<node::Identifier>> ident;
%type <std::shared_ptr<node::Operation>> math;
%type <node::NodeList> arguments;
%type <std::shared_ptr<node::Function>> function;
%type <std::shared_ptr<node::Application>> application;
%type <std::shared_ptr<node::Conditional>> conditional;
%type <node::TypeList> idents;
%type <std::shared_ptr<node::Declaration>> declaration;
%type <std::shared_ptr<node::Type>> type;

%nonassoc "="
%left "+" "-"
%left "*" "/"
%left ":"
%right THEN ELSE

%%
%start start;
start: program { result = $program; }

program:
  %empty { $$ = std::make_shared<node::Program>(); }
| expressions { $$ = $1; }
;

expressions:
  expression { $$ = std::make_shared<node::Program>(); $$->push_back($expression); }
| expressions[exprs] expression { $exprs->push_back($expression); }
;

string: STRING { $$ = std::make_shared<node::String>($1); }
number: NUMBER { $$ = std::make_shared<node::Number>($1); }
ident: IDENT { $$ = std::make_shared<node::Identifier>($1); }

expression:
  string { $$ = $1; }
| number { $$ = $1; }
| ident { $$ = $1; }
| declaration { $$ = $1; }
| function { $$ = $1; }
| application { $$ = $1; }
| conditional { $$ = $1; }
| math { $$ = $1; }
| '(' expression ')' { $$ = $2; }
;

math:
  expression[left] "+" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Addition); }
| expression[left] "-" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Subtraction); }
| expression[left] "/" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Division); }
| expression[left] "*" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Multiplication); }
;

arguments:
  %empty { $$ = node::NodeList(); }
| expression { $$ = node::NodeList(); $$->push_back($expression); }
| arguments[args] COMMA expression { $args->push_back($expression); }
;

function:
  PROGRAM "(" idents ")" DO program DONE { $$ = std::make_shared<node::Function>($idents, $program); }
;

application:
  ident CALL arguments ")" { $$ = std::make_shared<node::Application>($ident, $arguments); }
;

conditional:
  IF expression THEN program DONE { $$ = std::make_shared<node::Conditional>($expression, $program); }
| IF expression THEN program[true] ELSE program[false] DONE { $$ = std::make_shared<node::Conditional>($expression, $true, $false); }
;

idents:
  %empty { $$ = node::TypeList(); }
| ident { $$ = node::TypeList(); $$->push_back(std::make_shared<node::Type>($ident)); }
| idents[ids] COMMA ident { $ids->push_back(std::make_shared<node::Type>($ident)); }
;

type:
  ident { $$ = std::make_shared<node::Type>($ident); }
| "(" idents ")" "->" ident { $$ = std::make_shared<node::Type>($idents, $ident); }
;

declaration:
  ident ":" type { $$ = std::make_shared<node::Declaration>($ident, $type); }
| ident "=" expression { $$ = std::make_shared<node::Declaration>($ident, $expression); }
| ident ":" type "=" expression { $$ = std::make_shared<node::Declaration>($ident, $type, $expression); }
;

%%

void goat::parser::error(const location_type& l, const std::string& m) {
  std::cout << l << m << std::endl;
}