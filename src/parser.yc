%{
#include <string>
#include <vector>
#include <memory>
%}

%code requires {
#include "node.hh"
}

%code {
#include "driver.hh"
}

%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations
%define api.namespace {goat}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose

%param {void *scanner}
%param {goat::location &loc}
%param {std::unique_ptr<std::istream> &src}

%token
  END 0 "end of file"
  PROGRAM "program"
  IF "if"
  THEN "then"
  ELSE "else"
  DO "do"
  DONE "done"
  START_AT "start at"
  REPEAT "repeat"
  TIMES "times"
  BOX "box"
  IS "is"
  RETURNS "->"
  RETURN "return"
  EQUALS '='
  COLON ':'
  PLUS '+'
  MINUS '-'
  STAR '*'
  SLASH '/'
  LPAREN '('
  RPAREN ')'
;

%token <double> NUMBER "number"
%token <std::string> IDENT "identifier"
%token <std::string> STRING "string"

%printer { yyoutput << $$; } <*>;

%type <std::shared_ptr<node::Program>> program expressions;
%type <std::shared_ptr<node::Node>> expression;
%type <std::shared_ptr<node::String>> string;
%type <std::shared_ptr<node::Number>> number;
%type <std::shared_ptr<node::Identifier>> ident;
%type <std::shared_ptr<node::Operation>> math;
%type <node::NodeList> arguments;
%type <std::shared_ptr<node::Function>> function;
%type <std::shared_ptr<node::Application>> application;
%type <std::shared_ptr<node::Conditional>> conditional;
%type <node::TypeList> idents;
%type <std::shared_ptr<node::Declaration>> declaration;
%type <std::shared_ptr<node::Type>> type;

%left '+' '-'
%left '*' '/'
%left '='

%right THEN ELSE

%%

program:
  %empty { $$ = std::make_shared<node::Program>(); }
| expressions
;

expressions:
  expression { $$ = std::make_shared<node::Program>(); $$->push_back(std::move($1)); }
| expressions expression { $1->push_back(std::move($2)); }
;

string: STRING { $$ = std::make_shared<node::String>($1); }
number: NUMBER { $$ = std::make_shared<node::Number>($1); }
ident: IDENT { $$ = std::make_shared<node::Identifier>($1); }

expression:
  string { $$ = $1; }
| number { $$ = $1; }
| ident { $$ = $1; }
| declaration { $$ = $1; }
| function { $$ = $1; }
| application { $$ = $1; }
| conditional { $$ = $1; }
| math { $$ = $1; }
| '(' expression ')' { $$ = $2; }
;

math:
  expression '+' expression { $$ = std::make_shared<node::Operation>($1, $3, node::Addition); }
| expression '-' expression { $$ = std::make_shared<node::Operation>($1, $3, node::Subtraction); }
| expression '/' expression { $$ = std::make_shared<node::Operation>($1, $3, node::Division); }
| expression '*' expression { $$ = std::make_shared<node::Operation>($1, $3, node::Multiplication); }
;

arguments:
  %empty { $$ = node::NodeList(); }
| expression { $$ = node::NodeList(); $$->push_back(std::move($1)); }
| arguments ',' expression { $1->push_back(std::move($3)); }
;

function:
  PROGRAM '(' idents ')' DO program DONE { $$ = std::make_shared<node::Function>($3, $6); }
;

application:
  ident '(' arguments ')' { $$ = std::make_shared<node::Application>($1, $3); }
;

conditional:
  IF expression THEN program DONE { $$ = std::make_shared<node::Conditional>($2, $4); }
| IF expression THEN program ELSE program DONE { $$ = std::make_shared<node::Conditional>($2, $4, $6); }
;

idents:
  ident { $$ = node::TypeList(); $$->push_back(std::make_shared<node::Type>(std::move($1))); }
| idents ',' ident { $1->push_back(std::make_shared<node::Type>(std::move($3))); }
;

type:
  ident { $$ = std::make_shared<node::Type>($1); }
| '(' idents ')' RETURNS ident { $$ = std::make_shared<node::Type>($5, $2); }
;

declaration:
  ident ':' type { $$ = std::make_shared<node::Declaration>($1, $3); }
| ident '=' expression { $$ = std::make_shared<node::Declaration>($1, $3); }
| ident ':' type '=' expression { $$ = std::make_shared<node::Declaration>($1, $3, $5); }
;

%%

void goat::parser::error(const location_type& l, const std::string& m) {
  std::cout << l << m << std::endl;
}