%{
#include <string>
#include <vector>
#include <memory>
%}

%code requires {
#include "node.hh"
}

%code {
#include "driver.hh"
}

%skeleton "lalr1.cc"
%require "3.0.4"
%defines
%locations
%define api.namespace {goat}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose
%verbose

%param {void *scanner}
%param {goat::location &loc}
%parse-param {std::shared_ptr<goat::node::Program> result}

%token
  END 0 "end of file"
  PROGRAM "program"
  IF "if"
  THEN "then"
  ELSE "else"
  DO "do"
  DONE "done"
  START_AT "start at"
  REPEAT "repeat"
  TIMES "times"
  BOX "box"
  IS "is"
  RETURNS "->"
  RETURN "return"
  EQUALS '='
  COLON ':'
  PLUS '+'
  MINUS '-'
  STAR '*'
  SLASH '/'
  LPAREN '('
  CALL '('
  RPAREN ')'
  COMMA ','
;

%token <double> NUMBER "number"
%token <std::string> IDENT "identifier"
%token <std::string> STRING "string"

%printer { yyoutput << $$; } <*>;

%type <std::shared_ptr<node::Program>> program expressions;
%type <std::shared_ptr<node::Node>> expression;
%type <std::shared_ptr<node::String>> string;
%type <std::shared_ptr<node::Number>> number;
%type <std::shared_ptr<node::Identifier>> ident;
%type <std::shared_ptr<node::Operation>> math;
%type <node::NodeList> arguments;
%type <std::shared_ptr<node::Function>> function;
%type <std::shared_ptr<node::Application>> application;
%type <std::shared_ptr<node::Conditional>> conditional;
%type <node::TypeList> idents;
%type <std::shared_ptr<node::Declaration>> declaration;
%type <std::shared_ptr<node::Type>> type;

%nonassoc EQUALS
%left PLUS MINUS
%left STAR SLASH
%left COLON
%right THEN ELSE

%%
%start start;
start: program { result = $1; }

program:
  %empty { $$ = std::make_shared<node::Program>(); }
| expressions
;

expressions:
  expression { $$ = std::make_shared<node::Program>(); $$->push_back($expression); }
| expressions[exprs] expression { $exprs->push_back($expression); }
;

string: STRING { $$ = std::make_shared<node::String>($1); }
number: NUMBER { $$ = std::make_shared<node::Number>($1); }
ident: IDENT { $$ = std::make_shared<node::Identifier>($1); }

expression:
  string { $$ = $1; }
| number { $$ = $1; }
| ident { $$ = $1; }
| declaration { $$ = $1; }
| function { $$ = $1; }
| application { $$ = $1; }
| conditional { $$ = $1; }
| math { $$ = $1; }
| LPAREN expression RPAREN { $$ = $2; }
;

math:
  expression[left] PLUS expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Addition); }
| expression[left] MINUS expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Subtraction); }
| expression[left] SLASH expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Division); }
| expression[left] STAR expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Multiplication); }
;

arguments:
  %empty { $$ = node::NodeList(); }
| expression { $$ = node::NodeList(); $$->push_back($expression); }
| arguments[args] COMMA expression { $args->push_back($expression); }
;

function:
  PROGRAM LPAREN idents RPAREN DO program DONE { $$ = std::make_shared<node::Function>($idents, $program); }
;

application:
  ident CALL arguments RPAREN { $$ = std::make_shared<node::Application>($ident, $arguments); }
;

conditional:
  IF expression THEN program DONE { $$ = std::make_shared<node::Conditional>($expression, $program); }
| IF expression THEN program[true] ELSE program[false] DONE { $$ = std::make_shared<node::Conditional>($expression, $true, $false); }
;

idents:
  %empty { $$ = node::TypeList(); }
| ident { $$ = node::TypeList(); $$->push_back(std::make_shared<node::Type>($ident)); }
| idents[ids] COMMA ident { $ids->push_back(std::make_shared<node::Type>($ident)); }
;

type:
  ident { $$ = std::make_shared<node::Type>($ident); }
| LPAREN idents RPAREN RETURNS ident { $$ = std::make_shared<node::Type>($idents, $ident); }
;

declaration:
  ident COLON type { $$ = std::make_shared<node::Declaration>($ident, $type); }
| ident EQUALS expression { $$ = std::make_shared<node::Declaration>($ident, $expression); }
| ident COLON type EQUALS expression { $$ = std::make_shared<node::Declaration>($ident, $type, $expression); }
;

%%

void goat::parser::error(const location_type& l, const std::string& m) {
  std::cout << l << m << std::endl;
}