%require "3.0.4"

%{
#include <string>
#include <vector>
#include <memory>
%}

%code requires {
#include "inference.hh"
#include "node.hh"
}

%code {
#include "driver.hh"
}

%skeleton "lalr1.cc"
%defines
%locations
%define api.namespace {goat}
%define api.token.constructor
%define api.value.type variant
%define parse.assert
%define parse.trace
%define parse.error verbose
%verbose

%param {void *scanner}
%param {goat::location &loc}
%parse-param {std::shared_ptr<goat::node::Program> &result}
%parse-param {goat::inference::TypeFactory &typer}

%token END 0 "end of file"
%token PROGRAM "program"
%token IF "if"
%token THEN "then"
%token ELSE "else"
%token DO "do"
%token DONE "done"
%token START_AT "start at"
%token REPEAT "repeat"
%token TIMES "times"
%token RETURNS "->"
%token RETURN "return"
%token EQUALS "="
%token COLON ":"
%token PLUS "+"
%token MINUS "-"
%token STAR "*"
%token SLASH "/"
%token LPAREN "("
%token CALL "function call"
%token RPAREN ")"
%token COMMA ","

%token <double> NUMBER "number"
%token <std::string> IDENT "identifier"
%token <std::string> STRING "string"

%printer { yyoutput << $$; } <*>;

%type <std::shared_ptr<node::Program>> program;
%type <std::shared_ptr<node::Node>> expression;
%type <std::shared_ptr<node::String>> string;
%type <std::shared_ptr<node::Number>> number;
%type <std::shared_ptr<node::Identifier>> ident;
%type <std::shared_ptr<node::Operation>> math;
%type <std::shared_ptr<node::Argument>> argument;
%type <std::shared_ptr<node::ArgumentList>> arguments;
%type <std::shared_ptr<node::NodeList>> expressions;
%type <std::shared_ptr<node::Function>> function;
%type <std::shared_ptr<node::Application>> application;
%type <std::shared_ptr<node::Conditional>> conditional;
%type <std::shared_ptr<node::Declaration>> declaration;

%precedence IDENT
%nonassoc "="
%left "+" "-"
%left "*" "/"
%left ":"
%right THEN ELSE
%precedence "("

%expect 0
%%
%start start;
start: program { result = $program; }

program:
  %empty  { $$ = std::make_shared<node::Program>(); }
| expressions { $$ = std::make_shared<node::Program>(); $$->push_back($1); }
;

expressions:
  expression { $$ = std::make_shared<node::NodeList>(); $$->push_back($expression); }
| expressions[exprs] expression { $$ = $exprs; $$->push_back($expression); }
;

string: STRING { $$ = std::make_shared<node::String>($1); }
number: NUMBER { $$ = std::make_shared<node::Number>($1); }
ident: IDENT { $$ = std::make_shared<node::Identifier>($1, typer.next()); }

expression:
  string { $$ = $1; }
| number { $$ = $1; }
| ident %prec IDENT { $$ = $1; }
| declaration { $$ = $1; }
| function { $$ = $1; }
| application { $$ = $1; }
| conditional { $$ = $1; }
| math { $$ = $1; }
| "(" expression ")" { $$ = $2; }
;

math:
  expression[left] "+" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Addition); }
| expression[left] "-" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Subtraction); }
| expression[left] "/" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Division); }
| expression[left] "*" expression[right] { $$ = std::make_shared<node::Operation>($left, $right, node::Multiplication); }
;

argument:
  ident COLON expression {  $$ = std::make_shared<node::Argument>($ident, $expression); }
;

arguments:
  %empty { $$ = std::make_shared<node::ArgumentList>(); }
| argument { $$ = std::make_shared<node::ArgumentList>(); $$->push_back($argument); }
| arguments[args] COMMA argument { $$ = $args; $args->push_back($argument); }
;

application:
  ident "(" arguments ")" {
    $$ = std::make_shared<node::Application>($ident, $arguments, typer.next());
  }
;

function:
  PROGRAM "(" arguments ")" DO program DONE {
    std::vector<inference::Type> types;
    for(auto i : * $arguments) {
      types.push_back(i->type());
    }
    types.push_back(typer.next());
    auto f = inference::FunctionType(types);
    $$ = std::make_shared<node::Function>($arguments, $program, f);
  }
;

conditional:
  IF expression THEN program DONE { $$ = std::make_shared<node::Conditional>($expression, $program); }
| IF expression THEN program[true] ELSE program[false] DONE { $$ = std::make_shared<node::Conditional>($expression, $true, $false); }
;

declaration:
  ident "=" expression { $$ = std::make_shared<node::Declaration>($ident, $expression); }

%%

void goat::parser::error(const location_type& l, const std::string& m) {
  std::cout << l << m << std::endl;
}